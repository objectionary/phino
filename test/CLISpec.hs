{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- SPDX-FileCopyrightText: Copyright (c) 2025 Objectionary.com
-- SPDX-License-Identifier: MIT

module CLISpec (spec) where

import CLI (runCLI)
import Control.Exception
import Control.Monad (forM_, unless)
import Data.List (isInfixOf)
import Data.Version (showVersion)
import GHC.IO.Handle
import Paths_phino (version)
import System.Directory (removeFile)
import System.Exit (ExitCode (ExitFailure))
import System.IO
import Test.Hspec
import Text.Printf (printf)

withStdin :: String -> IO a -> IO a
withStdin input action =
  bracket (openTempFile "." "stdinXXXXXX.tmp") cleanup $ \(filePath, h) -> do
    hSetEncoding h utf8
    hPutStr h input
    hFlush h
    hClose h
    withFile filePath ReadMode $ \hIn -> do
      hSetEncoding hIn utf8
      bracket (hDuplicate stdin) restoreStdin $ \_ -> do
        hDuplicateTo hIn stdin
        hSetEncoding stdin utf8
        action
  where
    restoreStdin orig = hDuplicateTo orig stdin >> hClose orig
    cleanup (fp, _) = removeFile fp

withStdout :: IO a -> IO (String, a)
withStdout action =
  bracket
    (openTempFile "." "stdoutXXXXXX.tmp")
    cleanup
    ( \(path, hTmp) -> do
        hSetEncoding hTmp utf8
        oldOut <- hDuplicate stdout
        oldErr <- hDuplicate stderr
        hDuplicateTo hTmp stdout
        hDuplicateTo hTmp stderr

        result <-
          action `finally` do
            hFlush stdout
            hFlush stderr
            hDuplicateTo oldOut stdout >> hClose oldOut
            hDuplicateTo oldErr stderr >> hClose oldErr
            hClose hTmp

        captured <- readFile path
        _ <- evaluate (length captured)
        return (captured, result)
    )
  where
    cleanup (fp, _) = removeFile fp

testCLI :: [String] -> [String] -> Expectation
testCLI args outputs = do
  (out, _) <- withStdout (try (runCLI args) :: IO (Either ExitCode ()))
  forM_
    outputs
    ( \output ->
        unless (output `isInfixOf` out) $
          expectationFailure
            ("Expected that output contains:\n" ++ output ++ "\nbut got:\n" ++ out)
    )

testCLIFailed :: [String] -> String -> Expectation
testCLIFailed args output = do
  (out, result) <- withStdout (try (runCLI args) :: IO (Either ExitCode ()))
  out `shouldContain` output
  result `shouldBe` Left (ExitFailure 1)

spec :: Spec
spec = do
  it "prints version" $
    testCLI ["--version"] [showVersion version]

  it "prints help" $
    testCLI
      ["--help"]
      ["Phino - CLI Manipulator of ùúë-Calculus Expressions", "Usage:"]

  it "prints debug info with --log-level=DEBUG" $
    withStdin "Q -> [[]]" $
      testCLI ["rewrite", "--nothing", "--log-level=DEBUG"] ["[DEBUG]:"]

  describe "match" $ do
    it "finds bindings matching attribute-to-expression pattern" $
      withStdin "Q -> [[a -> b.c, d -> 42]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] ["a ‚Ü¶ Œæ.b.c", "d ‚Ü¶ Œ¶.org.eolang.number"]
    
    it "finds bindings with specific attribute patterns" $
      withStdin "Q -> [[foo -> 1, bar -> 2, baz -> 3]]" $
        testCLI ["match", "--pattern", "bar ‚Ü¶ !e"] ["bar ‚Ü¶ Œ¶.org.eolang.number"]
    
    it "finds xi-dispatches" $
      withStdin "Q -> [[a -> Œæ.b, c -> Œæ.d.e, f -> 42]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] ["a ‚Ü¶ Œæ.b", "c ‚Ü¶ Œæ.d.e", "f ‚Ü¶ Œ¶.org.eolang.number"]
    
    it "finds nested bindings" $
      withStdin "Q -> [[a -> [[b -> c]], d -> [[e -> [[f -> g]]]]]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] 
          ["a ‚Ü¶ ‚ü¶", "b ‚Ü¶ Œæ.c", "‚üß", "d ‚Ü¶ ‚ü¶", "e ‚Ü¶ ‚ü¶", "f ‚Ü¶ Œæ.g"]
    
    it "matches void bindings" $
      withStdin "Q -> [[a -> ‚àÖ, b -> c, d -> ‚àÖ]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ ‚àÖ"] ["a ‚Ü¶ ‚àÖ", "d ‚Ü¶ ‚àÖ"]
    
    it "matches delta bindings" $
      withStdin "Q -> [[Œî ‚§ç 01-02, x -> 42]]" $
        testCLI ["match", "--pattern", "Œî ‚§ç 01-02"] ["Œî ‚§ç 01-02"]  -- Meta bytes in binding patterns not supported
    
    it "matches lambda bindings" $
      withStdin "Q -> [[Œª ‚§ç func, a -> b]]" $
        testCLI ["match", "--pattern", "Œª ‚§ç !f"] ["Œª ‚§ç func"]
    
    it "matches rho bindings" $
      withStdin "Q -> [[œÅ -> a.b, x -> y]]" $
        testCLI ["match", "--pattern", "œÅ ‚Ü¶ !e"] ["œÅ ‚Ü¶ Œæ.a.b"]
    
    it "matches bindings with meta-bindings pattern" $
      withStdin "Q -> [[a -> b, c -> d, e -> f]]" $
        testCLI ["match", "--pattern", "!B"] []  -- !B is for multiple bindings, not single
    
    it "returns empty for no matches" $
      withStdin "Q -> [[a -> b.c]]" $
        testCLI ["match", "--pattern", "x ‚Ü¶ !e"] []
    
    it "matches expression patterns" $
      withStdin "Q -> [[a -> b.c.d]]" $
        testCLI ["match", "--pattern", "!e.c"] ["Œæ.b"]  -- Matches the base expression before .c
    
    it "matches this (Œæ) references" $
      withStdin "Q -> [[a -> Œæ, b -> Œæ.c]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ Œæ"] ["a ‚Ü¶ Œæ"]
    
    it "matches global (Œ¶) references" $
      withStdin "Q -> [[a -> Œ¶, b -> Œ¶.c]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ Œ¶"] ["a ‚Ü¶ Œ¶"]
    
    it "matches termination (‚ä•)" $
      withStdin "Q -> [[a -> ‚ä•, b -> c]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ ‚ä•"] ["a ‚Ü¶ ‚ä•"]
    
    it "handles invalid pattern gracefully" $
      withStdin "Q -> [[a -> b]]" $
        testCLIFailed ["match", "--pattern", "invalid pattern @#$"] 
          "Invalid pattern"
    
    it "requires pattern argument" $
      withStdin "Q -> [[a -> b]]" $
        testCLIFailed ["match"] "Missing: --pattern PATTERN"
    
    it "works with file input" $
      testCLI ["match", "--pattern", "!a ‚Ü¶ !e", "test-resources/cli/desugar.phi"]
        ["foo ‚Ü¶"]
    
    it "works with XMIR input format" $
      withStdin "<?xml version=\"1.0\"?><object><o name=\"a\">b</o></object>" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e", "--input=xmir"] ["a ‚Ü¶"]
    
    it "handles empty program" $
      withStdin "Q -> [[]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] []
    
    it "matches applications" $
      withStdin "Q -> [[a -> b(c ‚Ü¶ d)]]" $
        testCLI ["match", "--pattern", "!x ‚Ü¶ !e(c ‚Ü¶ !y)"] []  -- Application patterns are complex
    
    it "matches formations" $
      withStdin "Q -> [[a -> [[b -> c, d -> e]]]]" $
        testCLI ["match", "--pattern", "[[]]"] []  -- Formation patterns work differently
    
    it "matches complex nested patterns" $
      withStdin "Q -> [[a -> b.c(d ‚Ü¶ [[e -> f.g]])]]" $
        testCLI ["match", "--pattern", "e ‚Ü¶ !e"] ["e ‚Ü¶ Œæ.f.g"]
    
    it "handles ASCII input syntax" $
      withStdin "Q -> [[a -> b.c, d -> 42]]" $
        testCLI ["match", "--pattern", "!a -> !e"] ["a ‚Ü¶ Œæ.b.c", "d ‚Ü¶ Œ¶.org.eolang.number"]
    
    it "handles when condition for filtering" $
      withStdin "Q -> [[a -> 1, b -> 2, c -> 3]]" $
        testCLI ["match", "--pattern", "!x ‚Ü¶ !y", "--when", "eq: [\"!x\", \"b\"]"] 
          []  -- When conditions need proper YAML format
    
    it "handles invalid when condition" $
      withStdin "Q -> [[a -> b]]" $
        testCLIFailed ["match", "--pattern", "!a ‚Ü¶ !e", "--when", "invalid yaml {{{"]
          "Failed to parse condition"
    
    it "matches with different log levels" $
      withStdin "Q -> [[a -> b]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e", "--log-level=DEBUG"] 
          ["[DEBUG]:", "a ‚Ü¶ Œæ.b"]
    
    it "matches multiple occurrences of same pattern" $
      withStdin "Q -> [[a -> x.y, b -> x.y, c -> x.y]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] 
          ["a ‚Ü¶ Œæ.x.y", "b ‚Ü¶ Œæ.x.y", "c ‚Ü¶ Œæ.x.y"]
    
    it "handles special characters in patterns" $
      withStdin "Q -> [[a0 -> b, c1 -> d]]" $
        testCLI ["match", "--pattern", "a0 ‚Ü¶ !e"] ["a0 ‚Ü¶ Œæ.b"]
    
    it "matches meta-lambda patterns" $
      withStdin "Q -> [[Œª ‚§ç test, a -> b]]" $
        testCLI ["match", "--pattern", "Œª ‚§ç !f"] ["Œª ‚§ç test"]
    
    it "handles deeply nested structures" $
      withStdin "Q -> [[a -> [[b -> [[c -> [[d -> e]]]]]]]]" $
        testCLI ["match", "--pattern", "d ‚Ü¶ !e"] ["d ‚Ü¶ Œæ.e"]
    
    it "matches dispatches with multiple levels" $
      withStdin "Q -> [[a -> b.c.d.e.f]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] ["a ‚Ü¶ Œæ.b.c.d.e.f"]
    
    it "matches with meta-tail patterns" $
      withStdin "Q -> [[a -> b.c.d]]" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e!t"] []  -- Meta-tail patterns need special handling
    
    it "handles formations with rho" $
      withStdin "Q -> [[a -> [[œÅ -> ‚àÖ, b -> c]]]]" $
        testCLI ["match", "--pattern", "œÅ ‚Ü¶ ‚àÖ"] ["œÅ ‚Ü¶ ‚àÖ"]
    
    it "matches bytes patterns" $
      withStdin "Q -> [[Œî ‚§ç 40-45-00, a -> b]]" $
        testCLI ["match", "--pattern", "Œî ‚§ç 40-45-00"] ["Œî ‚§ç 40-45-00"]  -- Meta bytes in patterns not supported
    
    it "handles stdin read errors gracefully" $
      withStdin "" $
        testCLI ["match", "--pattern", "!a ‚Ü¶ !e"] []

  describe "rewrites" $ do
    it "desugares with --nothing flag from file" $
      testCLI
        ["rewrite", "--nothing", "test-resources/cli/desugar.phi"]
        ["Œ¶ ‚Ü¶ ‚ü¶\n  foo ‚Ü¶ Œ¶.org.eolang,\n  œÅ ‚Ü¶ ‚àÖ\n‚üß"]

    it "desugares with --nothing flag from stdin" $
      withStdin "{[[foo ‚Ü¶ QQ]]}" $
        testCLI ["rewrite", "--nothing"] ["Œ¶ ‚Ü¶ ‚ü¶\n  foo ‚Ü¶ Œ¶.org.eolang,\n  œÅ ‚Ü¶ ‚àÖ\n‚üß"]

    it "rewrites with single rule" $
      withStdin "{T(x -> Q.y)}" $
        testCLI ["rewrite", "--rule=resources/dc.yaml"] ["Œ¶ ‚Ü¶ ‚ä•"]

    it "normalizes with --normalize flag" $
      testCLI
        ["rewrite", "--normalize", "test-resources/cli/normalize.phi"]
        [ unlines
            [ "Œ¶ ‚Ü¶ ‚ü¶",
              "  x ‚Ü¶ ‚ü¶",
              "    œÅ ‚Ü¶ ‚ü¶",
              "      y ‚Ü¶ ‚ü¶ œÅ ‚Ü¶ ‚àÖ ‚üß,",
              "      œÅ ‚Ü¶ ‚àÖ",
              "    ‚üß",
              "  ‚üß,",
              "  œÅ ‚Ü¶ ‚àÖ",
              "‚üß"
            ]
        ]

    it "fails with negative --max-depth" $
      withStdin "" $
        testCLIFailed ["rewrite", "--max-depth=-1"] "--max-depth must be positive"

    it "fails with no rewriting options provided" $
      withStdin "" $
        testCLIFailed ["rewrite"] "no --rule, no --normalize, no --nothing are provided"

    it "normalizes from stdin" $
      withStdin "Œ¶ ‚Ü¶ ‚ü¶ a ‚Ü¶ ‚ü¶ b ‚Ü¶ ‚àÖ ‚üß (b ‚Ü¶ [[ ]]) ‚üß" $
        testCLI
          ["rewrite", "--normalize"]
          [ unlines
              [ "Œ¶ ‚Ü¶ ‚ü¶",
                "  a ‚Ü¶ ‚ü¶",
                "    b ‚Ü¶ ‚ü¶ œÅ ‚Ü¶ ‚àÖ ‚üß,",
                "    œÅ ‚Ü¶ ‚àÖ",
                "  ‚üß,",
                "  œÅ ‚Ü¶ ‚àÖ",
                "‚üß"
              ]
          ]

    it "rewrites with --sweet flag" $
      withStdin "Q -> [[ x -> 5]]" $
        testCLI
          ["rewrite", "--nothing", "--sweet"]
          ["{‚ü¶\n  x ‚Ü¶ 5\n‚üß}"]

    it "rewrites as XMIR" $
      withStdin "Q -> [[ x -> Q.y ]]" $
        testCLI
          ["rewrite", "--nothing", "--output=xmir"]
          ["<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "<object", "  <o base=\"Q.y\" name=\"x\"/>"]

    it "rewrites with XMIR as input" $
      withStdin "<object><o name=\"app\"><o name=\"x\" base=\"Q.number\"/></o></object>" $
        testCLI
          ["rewrite", "--nothing", "--input=xmir", "--sweet"]
          [ unlines
              [ "{‚ü¶",
                "  app ‚Ü¶ ‚ü¶",
                "    x ‚Ü¶ Œ¶.number",
                "  ‚üß",
                "‚üß}"
              ]
          ]

    it "rewrites as XMIR with omit-listing flag" $
      withStdin "Q -> [[ x -> Q.y ]]" $
        testCLI
          ["rewrite", "--nothing", "--output=xmir", "--omit-listing"]
          ["<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "<object", "<listing>1 line(s)</listing>", "  <o base=\"Q.y\" name=\"x\"/>"]

    it "does not fail on exactly 1 rewriting" $
      withStdin "{‚ü¶ t ‚Ü¶ ‚ü¶ x ‚Ü¶ \"foo\" ‚üß ‚üß}" $
        testCLI
          ["rewrite", "--rule=test-resources/cli/simple.yaml", "--must=1", "--sweet"]
          ["x ‚Ü¶ \"bar\""]

    it "fails with --nothing and --must" $
      withStdin "Q -> [[ ]]" $
        testCLIFailed ["rewrite", "--nothing", "--must"] "it's expected exactly 1 rewriting cycles happened, but rewriting stopped after 0"

    it "fails with --normalize and --must" $
      withStdin "Q -> [[ x -> [[ y -> 5 ]].y ]].x" $
        testCLIFailed ["rewrite", "--max-depth=2", "--normalize", "--must"] "it's expected exactly 1 rewriting cycles happened, but rewriting is still going"

    it "prints to target file" $
      withStdin "Q -> [[ ]]" $
        bracket
          (openTempFile "." "targetXXXXXX.tmp")
          (\(path, _) -> removeFile path)
          ( \(path, h) -> do
              hClose h
              testCLI
                ["rewrite", "--nothing", "--sweet", printf "--target=%s" path]
                [printf "The result program was saved in '%s'" path]
              content <- readFile path
              content `shouldBe` "{‚ü¶‚üß}"
          )

    it "rewrites with cycles" $
      withStdin "Q -> [[ x -> \"x\" ]]" $
        testCLI
          ["rewrite", "--sweet", "--rule=test-resources/cli/infinite.yaml", "--max-depth=1", "--max-cycles=2"]
          [ unlines
              [ "{‚ü¶",
                "  x ‚Ü¶ \"x_hi_hi\"",
                "‚üß}"
              ]
          ]
    
    it "fails with --depth-sensitive" $
      withStdin "Q -> [[ x -> \"x\"]]" $
        testCLIFailed
          ["rewrite", "--depth-sensitive", "--max-depth=1", "--max-cycles=1", "--rule=test-resources/cli/infinite.yaml"]
          "[ERROR]: With option --depth-sensitive it's expected rewriting iterations amount does not reach the limit: --max-depth=1"

    it "fails on --sweet and --output=xmir together" $
      withStdin "Q -> [[ ]]" $
        testCLIFailed
          ["rewrite", "--sweet", "--output=xmir", "--nothing"]
          "The --sweet and --output=xmir can't stay together"

  describe "dataize" $ do
    it "dataizes simple program" $
      withStdin "Q -> [[ D> 01- ]]" $
        testCLI ["dataize"] ["01-"]

    it "fails to dataize" $
      withStdin "Q -> [[ ]]" $
        testCLIFailed ["dataize"] "[ERROR]: Could not dataize given program"
